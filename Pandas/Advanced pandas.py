# -*- coding: utf-8 -*-
"""Projeto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LqiTlxlD9Tc_aIZRgJFvhvnQKpxwns9i

# PANDAS AVANÇADO
---

# CARREGANDO OS DADOS
---

## Configurações do projeto

### Importando pacotes
"""

import pandas as pd

pd.__version__

"""### Opções de configuração

[Documentação](https://pandas.pydata.org/pandas-docs/stable/user_guide/options.html)
"""

pd.get_option('display.max_rows')

pd.get_option('display.max_columns')

"""[Opções disponíveis](https://pandas.pydata.org/pandas-docs/stable/user_guide/options.html#available-options)"""

pd.describe_option()

import numpy as np

df=pd.DataFrame(np.arange(10000).reshape(100,100))
df

pd.set_option('display.max_rows', 1000)
pd.set_option('display.max_columns', 100)

df

pd.reset_option('display.max_rows')

df

"""## Carregando os dados

### Arquivos JSON - `read_json`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_json.html)

## JSON

JSON (**J**ava**S**cript **O**bject **N**otation - Notação de Objetos JavaScript) é uma formatação leve de troca de dados. Para seres humanos, é fácil de ler e escrever. Para máquinas, é fácil de interpretar e gerar. Está baseado em um subconjunto da linguagem de programação JavaScript, Standard ECMA-262 3a Edição - Dezembro - 1999. JSON é em formato texto e completamente independente de linguagem, pois usa convenções que são familiares às linguagens C e familiares, incluindo C++, C#, Java, JavaScript, Perl, Python e muitas outras. Estas propriedades fazem com que JSON seja um formato ideal de troca de dados.

[fonte](https://www.json.org/json-pt.html)

[Online JSON Viewer](http://jsonviewer.stack.hu/)
"""

data_json = '{"A": [1, 2, 3, 4], "B": [5,6,7,8], "C": [9,10,11,12]}'
data_json

dados = pd.read_json(
    path_or_buf=data_json,
    orient='index'
)
dados

#forma considerada default
dados1 = pd.read_json(
    path_or_buf=data_json,
    orient='columns'
)
dados1





"""### Arquivos EXCEL - `read_excel`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html)
"""



"""# TRANSFORMANDO E TRATANDO OS DADOS
---

## Transformando dados no formato JSON para uma tabela
"""

dados = pd.read_json(
    path_or_buf=data_json,
    orient='columns'
)
dados1

"""### `json_normalize`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.json_normalize.html)
"""

dados = pd.read_json(
    path_or_buf='realestates.json',
    orient='columns'
)
dados

dados_normal= pd.json_normalize(data=dados.normal)
dados_normal

dados_normal['listings'].iloc[0]

type(dados_normal['listings'].iloc[0])

len(dados_normal['listings'].iloc[0])

dados_normal_listings=pd.json_normalize(data=dados_normal['listings'].iloc[0], sep='_')
dados_normal_listings

#fez normalização de todos os níveis do dicionário no JSON

dados_normal_listings=pd.json_normalize(
    data=dados_normal['listings'].iloc[0],
     sep='_', max_level= 2)
dados_normal_listings

#Limitando um level específico do dicionário no JSON

dados_normal_listings=pd.json_normalize(
    data=dados.normal, record_path=['listings'],
     sep='_')
dados_normal_listings
#aqui usando record path é possível retornar diretamente todo o JSON em um DataFrame

dados_highlights_listings=pd.json_normalize(
    data=dados.highlights, record_path=['listings'],
     sep='_')
dados_highlights_listings

"""## Trabalhando com dados textuais

### Transformando *strings* em listas do Python
"""

dados_normal_listings.head(2)

lista_str= dados_normal_listings.loc[0, 'imovel_caracteristicas_propriedade']
lista_str

type(lista_str)

lista_str[0]

#limpando as strings da lista
lista_str[1:-1]

lista_str.strip('[]') #esse funciona da mesma forma que o anterior

lista_str[1:-1].replace("'", "")

lista_str[1:-1].replace("'", "").split(", ")

#agora podemos definir de fato a lista
lista= lista_str[1:-1].replace("'", "").split(", ")

type(lista)

texto = dados_normal_listings.loc[:,'imovel_caracteristicas_propriedade']
texto



"""#### Métodos de *strings*

[Documentação](https://docs.python.org/3.6/library/stdtypes.html#string-methods)
"""

#replace não deve ser usado desta forma, pois não retornará nenhum resultado alterado
texto.str[1:-1].replace("'", "")

texto.str[1:-1].str.replace("'", "")
#sempre que o retorno ainda for uma series é necessário chamar novamente o método

texto= texto.str[1:-1].str.replace("'", "").str.split(', ')

type(texto[0])









"""#### `str`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.html)
"""

















"""#### `filter`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.filter.html)
"""

columns= dados_normal_listings.filter(like='imovel_caracteristicas_').columns

for column in columns:
  dados_normal_listings[column] = dados_normal_listings[column].str[1:-1].str.replace("'", "").str.split(', ')
  dados_highlights_listings[column] = dados_highlights_listings[column].str[1:-1].str.replace("'", "").str.split(', ')

dados_normal_listings.loc[0, 'imovel_caracteristicas_propriedade'][0]

"""# COMBINANDO CONJUNTOS DE DADOS
---
"""





"""## Empilhando *DataFrames*

### `append`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.append.html)
"""

dados_normal_listings.append(dados_highlights_listings)

dados_normal_listings.append(dados_highlights_listings, ignore_index= True)

dados_listings = dados_normal_listings.append(dados_highlights_listings)



"""### `concat`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html)
"""

dados_listings= pd.concat([dados_normal_listings, dados_highlights_listings], ignore_index=True)



"""## Combinando *DataFrames* a partir de uma chave de ligação"""

dados_listings.head(2)

bairros = pd.read_excel(
    io = 'bairros.xlsx',
    sheet_name = 'Preço médio por tipo',
    usecols='C:E',
    header= 2,
    index_col= [0, 1],
    names=['bairros', 'tipo', 'valor_m2_bairro']
    )
bairros

bairros_amostra = dados_listings['imovel_endereco_bairro']
bairros_amostra

"""### Tratando a variável de ligação

#### Selecionando a variável de ligação nos dois *DataFrames*
"""

bairros_amostra = dados_listings['imovel_endereco_bairro']
bairros_amostra

"""[Documentação: `get_level_values`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.MultiIndex.get_level_values.html)"""

bairros_todos = bairros.index.get_level_values('bairros')
bairros_todos

"""#### Identificando e eliminando valores duplicados - `nunique` e `unique`

[Documentação: `nunique`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.nunique.html)

[Documentação: `unique`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.unique.html)
"""

bairros_amostra.shape

bairros_amostra.nunique()

bairros_amostra.unique()

bairros_amostra = pd.Series(bairros_amostra.unique())

type(bairros_amostra.unique())

"""---"""

bairros_todos = pd.Series(bairros_todos.unique())

bairros_amostra

bairros_amostra.isin(bairros_todos)

bairros.loc['Freguesia']

bairros.loc['Jacarepaguá']

dados_listings['imovel_endereco_bairro'].replace('Freguesia (Jacarepaguá)', 'Freguesia', inplace=True)

bairros_amostra = pd.Series(dados_listings['imovel_endereco_bairro'].unique())
bairros_amostra

bairros_amostra.isin(bairros_todos)

"""#### Verificando se existe correspondência entre as variáveis de ligação

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.isin.html)
"""









"""#### Ajustando os valores

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.replace.html)
"""







"""### Combinando os *DataFrames*

#### `merge`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.merge.html)

```
pandas.merge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=False, suffixes='_x', '_y', copy=True, indicator=False, validate=None)
```

**Parameters**

- **left**: DataFrame


- **right**: DataFrame


- **how**: {‘left’, ‘right’, ‘outer’, ‘inner’}, *default* ‘inner’

        Tipo de junção que será realizada.

        - left: usa apenas as chaves do DataFrame especificado no parâmetro left.

        - right: usa apenas as chaves do DataFrame especificado no parâmetro right.

        - outer: considera todos os registros dos DataFrames especificados nos parâmetros left e right, isto é, faz a união das chaves.

        - inner: considera apenas a interseção das chaves dos DataFrames especificados nos parâmetros left e right.


- **on**: label ou list

        Nomes das colunas ou dos índices que serão utilizados na junção. Estes devem ser encontrados em ambos os DataFrames.


- **left_on**: label ou list, or array-like

        Nomes das colunas ou dos índices do DataFrame especificado em left que serão utilizados na junção.


- **right_on**: label or list, or array-like

        Nomes das colunas ou dos índices do DataFrame especificado em right que serão utilizados na junção.


- **left_index**: bool, *default False*

        Indica se o índice do DataFrame especificado no parâmetro left deve ser utilizado como chave de junção.


- **right_index**: bool, *default False*

        Indica se o índice do DataFrame especificado no parâmetro right deve ser utilizado como chave de junção.
"""

dados_listings = pd.merge(
    left= dados_listings,
    right = bairros,
    left_on= ['imovel_endereco_bairro', 'imovel_tipos_propriedade'],
    right_index = True
)
dados_listings

"""# ADICIONANDO INFORMAÇÕES
---

## Criando as colunas `quartos`, `suites` e `banheiros`
"""

dados_listings['anuncio_descricao'].values[:10]

"""### `str.extractall`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.extractall.html)
"""

config = dados_listings['anuncio_descricao'].str.extractall('(\d+)')
# (\d+) considera encontrar um digito númerico e o + considera
#que se houver dois digitos eles são somente um número

"""### `unstack`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.unstack.html)
"""

config = config.unstack().rename(columns={0: 'quartos', 1: 'suites', 2: 'banheiros'})



"""### `droplevel`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.droplevel.html)
"""

config = config.droplevel(level=0, axis=1)
config

dados_listings = pd.merge(dados_listings, config, left_index=True, right_index=True)
dados_listings

"""## Criando novas classificações

### Com dados categóricos - `map`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.map.html)
"""

tipo_uso = {
    'Apartamento': 'Residencial',
    'Casa': 'Residencial',
    'Cobertura': 'Residencial',
    'Consultório': 'Comercial',
    'Imóvel Comercial': 'Comercial',
    'Loja': 'Comercial',
    'Sala Comercial': 'Comercial'
}

dados_listings.imovel_tipos_propriedade.map(tipo_uso)

imovel_tipos_uso = dados_listings.imovel_tipos_propriedade.map(tipo_uso)

"""#### `insert`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.insert.html)
"""

daods_listings = dados_listings.insert(loc=0, column='imovel_tipos_uso', value=imovel_tipos_uso)
dados_listings



"""### Com dados numéricos - `cut`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.cut.html)

#### Utilizando classes fixas
"""

valor_min = dados_listings['anuncio_valores_venda'].min()

valor_max = dados_listings['anuncio_valores_venda'].max()

rotulos = ['Popular', 'Padrão', 'Alto padrão']

"""#### Utilizando classes personalizadas"""

pd.cut(x= dados_listings['anuncio_valores_venda'], bins=3, labels=rotulos)

classes = [valor_min, 400000, 2000000, valor_max]

pd.cut(x= dados_listings['anuncio_valores_venda'], bins=classes, labels=rotulos, include_lowest=True)

dados_listings['classe_valor'] = pd.cut(x= dados_listings['anuncio_valores_venda'], bins=classes, labels=rotulos, include_lowest=True)
dados_listings

"""## Novas colunas derivadas das informações existentes

### Valor por m²
"""

dados_listings['valor_m2'] = dados_listings['anuncio_valores_venda']/dados_listings['imovel_area']

dados_listings[['anuncio_valores_venda', 'imovel_area', 'valor_m2']].iloc[16:19]

"""#### `apply`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html)
"""

vm2 = lambda data: data['anuncio_valores_venda']/data['imovel_area'] if data['imovel_area'] !=0 else 0

dados_listings['valor_m2'] = dados_listings.apply(vm2, axis=1)

dados_listings[['anuncio_valores_venda', 'imovel_area', 'valor_m2']].iloc[16:19]

"""### Piscina?"""

dados_listings['Piscina'] = dados_listings['imovel_caracteristicas_condominio'].apply(lambda x: 'Piscina' in x)
dados_listings[['imovel_caracteristicas_condominio', 'Piscina']].head()

pd.set_option('display.max_colwidth', None)

dados_listings[['imovel_caracteristicas_condominio', 'Piscina']].head()

"""# TABULAÇÕES E SUMARIZAÇÕES
---

## Agrupamentos
"""



"""### `aggregate`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.aggregate.html)
"""

dados_listings[['anuncio_valores_venda', 'anuncio_valores_condominio', 'anuncio_valores_iptu']].agg(['sum', 'mean', 'std'])



"""### `groupby`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html)
"""

grp = dados_listings[['imovel_tipos_propriedade', 'valor_m2']].groupby(by='imovel_tipos_propriedade')

grp.mean()

grp.agg(['min', 'mean', 'max', 'std'])

#multindex
grp = dados_listings[['imovel_tipos_propriedade', 'classe_valor','valor_m2']]\
.groupby(by=['imovel_tipos_propriedade', 'classe_valor'])

grp.mean()



"""### `value_counts`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.value_counts.html)
"""

dados_listings.value_counts(subset='imovel_tipos_propriedade', normalize=True)

dados_listings.value_counts(subset=['imovel_tipos_propriedade', 'classe_valor'])

dados_listings.value_counts(subset=['imovel_tipos_propriedade', 'classe_valor'], normalize=True).to_frame(name='percentual')*100

"""#### `to_frame`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.to_frame.html)
"""



"""## Mudando o formato de um *DataFrame*

### `unstack`

Faz a rotação ou o pivoteamento das linhas para as colunas.

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.unstack.html)
"""

bairros

bairros.unstack(level=0)



"""### `stack`

Faz a rotação ou o pivoteamento das colunas de um *DataFrame* para as linhas.

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.stack.html)
"""

#multindex
grp = dados_listings[['imovel_tipos_propriedade', 'classe_valor','valor_m2']]\
.groupby(by=['imovel_tipos_propriedade', 'classe_valor'])

grp_stat = grp.agg(['min', 'mean', 'max', 'std']).round(2)
grp_stat

grp_stat.stack(dropna=False)

grp_stat.unstack(level=1)

"""## Criando tabelas dinâmicas

### `pivot`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pivot.html)
"""

#multindex
grp = dados_listings[['imovel_tipos_propriedade', 'classe_valor','valor_m2']]\
.groupby(by=['imovel_tipos_propriedade', 'classe_valor'])

grp_stat = grp.agg(['min', 'mean', 'max', 'std']).round(2)
grp_stat

"""#### `droplevel`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.droplevel.html)
"""

grp_stat = grp_stat.droplevel(level=0, axis='columns')
grp_stat

"""#### `reset_index`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.reset_index.html)
"""

grp_stat.reset_index(inplace=True)

grp_stat

"""### `pivot_table`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.pivot_table.html)
"""

grp_stat.pivot(
    index='imovel_tipos_propriedade',
    columns='classe_valor',
    values='mean'
)

dados_listings.pivot_table(
    values='valor_m2',
    index='imovel_tipos_propriedade',
    columns='classe_valor',
    fill_value='-',
    margins=True,
    margins_name='Média Geral',
    aggfunc='mean'
)

dados_listings.pivot_table(
    values='valor_m2',
    index=['imovel_tipos_propriedade', 'classe_valor'],
    columns=['anuncio_tipos_listagem', 'Piscina'],
    fill_value='-',
    margins=True,
    dropna=False,
    margins_name='Média Geral',
    aggfunc='mean'
)

"""# TABULAÇÕES E ESTILIZAÇÃO
---

## Tabulações a partir de informações no formato de listas

### `explode`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.explode.html)
"""

carac_prop = dados_listings['imovel_caracteristicas_propriedade']
carac_prop

carac_prop_itens = carac_prop.explode()
carac_prop_itens

pd.merge(
    left= carac_prop_itens.value_counts(),
    right= carac_prop_itens.value_counts(normalize=True),
    left_index=True,
    right_index=True,
)

"""#### `where`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.where.html)
"""

carac_prop_itens.where(
    cond=carac_prop_itens!='',
    other='Sem característica',
    inplace=True
)
pd.merge(
    left= carac_prop_itens.value_counts(),
    right= carac_prop_itens.value_counts(normalize=True),
    left_index=True,
    right_index=True,
)



"""## Estilizando um DataFrame

### `style`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.style.html)
"""

freq_table= pd.merge(
    left= carac_prop_itens.value_counts(sort=False),
    right= carac_prop_itens.value_counts(normalize=True, sort=False),
    left_index=True,
    right_index=True,
)
freq_table

freq_table.query("index != 'Sem característica'", inplace= True)

freq_table.rename(columns={
    'imovel_caracteristicas_propriedade_x': 'Frequencias',
    'imovel_caracteristicas_propriedade_y': 'Percentual'
    }, inplace=True)
freq_table.rename_axis('Caracteristicas', inplace=True)
freq_table

"""#### `format`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.format.html)
"""

freq_table.style.format({'Percentual':'{:.2%}'})

"""#### `bar`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.bar.html)
"""

freq_table.style.format({'Percentual':'{:.2%}'})\
                .bar(subset='Percentual', vmin=0.05, color='lightblue')

"""#### `applymap`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.applymap.html)
"""

freq_table.style.format({'Percentual':'{:.2%}'})\
                .bar(subset='Percentual', vmin=0.05, color='lightblue')\
                .applymap(lambda x: f"color:{'red' if x >= 35 else 'black'}", subset='Frequencias')

freq_table.style.format({'Percentual':'{:.2%}'})\
                .bar(subset='Percentual', vmin=0.05, color='lightblue')\
                .applymap(lambda x: f"color:{'red' if x >= 35 else 'black'}", subset='Frequencias')\
                .applymap(lambda x: f"font-weight:{'bold' if x >= 35 else 'normal'}", subset='Frequencias')

"""#### `highlight_max` e `highlight_min`

[Documentação: `highlight_max`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.highlight_max.html)

[Documentação: `highlight_min`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.highlight_min.html)
"""

bairros

bairros.unstack()











"""#### `background_gradient`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.background_gradient.html)
"""







"""#### `to_excel`

[Documentação](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.io.formats.style.Styler.to_excel.html)
"""



"""# ANEXOS
---

### Opções para o parâmetro `cmap`

[Documentação](https://matplotlib.org/3.3.2/tutorials/colors/colormaps.html)
"""

import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib import cm
from collections import OrderedDict

cmaps = OrderedDict()

cmaps['Perceptually Uniform Sequential'] = [
            'viridis', 'plasma', 'inferno', 'magma', 'cividis']

cmaps['Sequential'] = [
            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',
            'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
            'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']

cmaps['Sequential (2)'] = [
            'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink',
            'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia',
            'hot', 'afmhot', 'gist_heat', 'copper']

cmaps['Diverging'] = [
            'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',
            'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic']

cmaps['Cyclic'] = ['twilight', 'twilight_shifted', 'hsv']

cmaps['Qualitative'] = ['Pastel1', 'Pastel2', 'Paired', 'Accent',
                        'Dark2', 'Set1', 'Set2', 'Set3',
                        'tab10', 'tab20', 'tab20b', 'tab20c']

cmaps['Miscellaneous'] = [
            'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern',
            'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg',
            'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral',
            'gist_ncar']

nrows = max(len(cmap_list) for cmap_category, cmap_list in cmaps.items())
gradient = np.linspace(0, 1, 256)
gradient = np.vstack((gradient, gradient))


def plot_color_gradients(cmap_category, cmap_list, nrows):
    fig, axes = plt.subplots(nrows=nrows)
    fig.subplots_adjust(top=0.95, bottom=0.01, left=0.2, right=0.99)
    axes[0].set_title(cmap_category + ' colormaps', fontsize=14)

    for ax, name in zip(axes, cmap_list):
        ax.imshow(gradient, aspect='auto', cmap=plt.get_cmap(name))
        pos = list(ax.get_position().bounds)
        x_text = pos[0] - 0.01
        y_text = pos[1] + pos[3]/2.
        fig.text(x_text, y_text, name, va='center', ha='right', fontsize=10)

    # Turn off *all* ticks & spines, not just the ones with colormaps.
    for ax in axes:
        ax.set_axis_off()


for cmap_category, cmap_list in cmaps.items():
    plot_color_gradients(cmap_category, cmap_list, nrows)

plt.show()

